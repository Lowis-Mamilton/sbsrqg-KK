<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<title>幸運公式產生器</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="theme-color" content="#f6d8ad" />
<link rel="manifest" href="manifest.json" />
<link rel="apple-touch-icon" href="icons/icon-192x192.png" />
<style>
:root{ 
  --bg:#ffffff; --panel:#f6d8ad; --accent:#7fb8ff; 
  --card-shadow: rgba(0,0,0,0.12); 
  --font: "Microsoft JhengHei", "Noto Sans TC", Arial, sans-serif; 
}
html,body{
  height:100%; margin:0;
  background:var(--bg); font-family:var(--font);
  overflow:hidden;
}
.wrap{ 
  max-width:1100px; margin:0 auto; padding:16px; box-sizing:border-box;
  height:100vh; display:flex; flex-direction:column;
}
h1{ text-align:center; margin:6px 0 14px; font-size:26px; color:#222; }

/* 上方卡片列 */
.top-row{ display:flex; gap:18px; justify-content:center; align-items:center; }
.card{ 
  background:var(--panel); border-radius:14px; padding:14px 20px; 
  box-shadow:0 6px 12px var(--card-shadow); 
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  min-width:160px; min-height:120px;
}
.target-card{ gap:12px; }
#targetDigits { display:flex; gap:8px; justify-content:center; }
.digit, .lucky-token {
  width:60px; height:60px; border-radius:10px;
  background:var(--accent); color:#fff;
  display:flex; align-items:center; justify-content:center;
  font-size:26px; font-weight:800;
  box-shadow:0 3px 0 rgba(0,0,0,0.06);
}
.lucky-card{ text-align:center; }
.lucky-title{ font-size:15px; font-weight:600; color:#333; margin-bottom:10px; }

/* 公式區 */
.mid { 
  margin:18px auto 10px; 
  width:100%; 
  display:flex; 
  justify-content:center; 
}
.formula-card { 
  width:100%; 
  max-width:720px;
  background:var(--panel); 
  border-radius:20px; 
  padding:16px; 
  box-shadow:0 6px 12px var(--card-shadow); 
  box-sizing:border-box; 
  display:flex; 
  gap:12px; 
  align-items:flex-start; 
}
.left { flex:1; }
.right { width:90px; flex:0 0 90px; text-align:center; }
.left h3, .right h3 { 
  margin:0 0 6px 0; 
  font-size:18px; 
  color:#111; 
}
.rows { display:flex; flex-direction:column; gap:6px; }
.row { 
  display:grid; 
  grid-template-columns: 24px 1fr; 
  align-items:center; 
  gap:6px; 
  padding:4px 2px; 
  border-radius:6px; 
  min-height:26px; 
  background:transparent; 
}
.row .idx { font-weight:700; color:#222; font-size:16px; }
.row .expr { font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#0c0c0c; }
.right .err-row { 
  height:26px; 
  display:flex; 
  align-items:center; 
  justify-content:center;
  font-weight:700; 
  color:#b23d00; 
  font-size:16px;
}

/* 底部按鈕 */
.bottom { display:flex; justify-content:center; gap:12px; margin-top:auto; padding-top:6px; }
.btn { background:#7fb8ff; color:#fff; border:none; padding:12px 26px; font-size:18px; border-radius:12px; cursor:pointer; box-shadow:0 8px 12px rgba(0,0,0,0.08); }

/* 手動改題彈窗 */
#manualModal {
  position:fixed; top:0; left:0; right:0; bottom:0;
  background:rgba(0,0,0,0.5);
  display:none; align-items:center; justify-content:center;
}
.modal-content {
  background:#fff; padding:20px; border-radius:12px;
  max-width:300px; width:100%;
  display:flex; flex-direction:column; gap:12px;
}
.modal-content label { font-size:14px; font-weight:600; }
.modal-content input, .modal-content select {
  padding:6px; font-size:16px; border-radius:6px; border:1px solid #ccc;
}
.modal-actions { display:flex; justify-content:flex-end; gap:10px; }
.modal-actions button { padding:6px 14px; border:none; border-radius:6px; cursor:pointer; }
.modal-actions .ok { background:#7fb8ff; color:#fff; }
.modal-actions .cancel { background:#aaa; color:#fff; }

/* 新增：運算中提示 */
.loading-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  display: none; align-items: center; justify-content: center;
  z-index: 1000;
}
.loading-overlay span {
  color: #fff; font-size: 24px; font-weight: 600;
  background: rgba(0, 0, 0, 0.6); padding: 12px 24px; border-radius: 8px;
}

@media (max-width:980px){
  .wrap{padding:10px;}
  .formula-card{flex-direction:column; gap:12px; border-radius:18px;}
  .right{width:100%;}
}
@media (max-width: 600px) {
  html, body { overflow:auto; }
  .wrap { height:auto; min-height:100vh; }
  .top-row { flex-direction: column; align-items: stretch; gap: 12px; }
  .card { width:100%; min-width:unset; }
  .button {
    width: auto;
    min-width: 100px;
    padding: 10px 16px;
    font-size: 16px;
  }
  .formula-card { flex-direction: row; align-items:flex-start; }
  .left, .right { width:auto; flex:1; }
  .right { max-width:90px; }
}
</style>
</head>
<body>
<div class="wrap" role="main">
<h1>國小高年級 - 步步為營</h1>
<div class="top-row">
  <div class="card target-card">
    <div style="text-align:center; font-size:14px; color:#333; margin-right:8px;">目標數字</div>
    <div id="targetDigits" style="display:flex; gap:12px; align-items:center;">
      <div class="digit" id="d0">-</div>
      <div class="digit" id="d1">-</div>
      <div class="digit" id="d2">-</div>
    </div>
  </div>
  <div class="card lucky-card"><div class="lucky-title">幸運方塊A</div><div class="lucky-token" id="luckA">-</div></div>
  <div class="card lucky-card"><div class="lucky-title">幸運方塊B</div><div class="lucky-token" id="luckB">-</div></div>
  <div class="card lucky-card"><div class="lucky-title">幸運方塊C</div><div class="lucky-token" id="luckC">-</div></div>
</div>

<div class="mid">
  <div class="formula-card">
    <div class="left">
      <h3>參考公式</h3>
      <div class="rows" id="formulaRows"></div>
    </div>
    <div class="right">
      <h3>誤差值</h3>
      <div style="display:flex;flex-direction:column;gap:8px;" id="errorRows"></div>
    </div>
  </div>
</div>

<div class="bottom">
  <button class="btn" id="regenBtn">重新抽題</button>
  <button class="btn" id="manualBtn">手動改題</button>
</div>
</div>

<!-- 手動輸入的彈窗 -->
<div id="manualModal">
  <div class="modal-content">
    <label>目標數字 (100~999)</label>
    <input type="number" id="manualTarget" min="100" max="999" />
    <label>幸運方塊 A (0~9)</label>
    <input type="number" id="manualA" min="0" max="9" />
    <label>幸運方塊 B (× ÷)</label>
    <select id="manualB">
      <option value="*">×</option>
      <option value="/">÷</option>
    </select>
    <label>幸運方塊 C (＋ －)</label>
    <select id="manualC">
      <option value="+">＋</option>
      <option value="-">－</option>
    </select>
    <div class="modal-actions">
      <button class="ok" id="manualOk">確定</button>
      <button class="cancel" id="manualCancel">取消</button>
    </div>
  </div>
</div>

<!-- 新增：運算中提示 -->
<div class="loading-overlay" id="loadingOverlay">
  <span>運算中...</span>
</div>

<script>

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('Service Worker registered! Scope: ', registration.scope);
      })
      .catch((err) => {
        console.log('Service Worker registration failed: ', err);
      });
  });
}
/* ---------- 工具與原本共用函式（保留風格） ---------- */
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(arr){ const a=arr.slice(); for (let i=a.length-1;i>0;i--){ const j=randInt(0,i); [a[i],a[j]]=[a[j],a[i]];} return a; }

const OPS_SHOW = {"*":"×","/":"÷","+":"＋","-":"－"};
const ALL_OPS = ["+","-","*","/"];
const MUL_DIV = ["*","/"];
const ADD_SUB = ["+","-"];

// 安全運算（防 /0 與非數）
function safeEval(expr){
  if ( /\/\s*0(?![0-9])/g.test(expr) ) return NaN;
  try {
    const v = Function('"use strict";return ('+expr+')')();
    if (typeof v === "number" && isFinite(v)) return v;
  } catch(e){}
  return NaN;
}
function fmtNum(x){
  if (x===null || isNaN(x)) return "-";
  if (Math.abs(x - Math.round(x)) < 1e-9) return String(Math.round(x));
  return (Math.round(x*100)/100).toFixed(2);
}

/* 數字候選池 (0-9, 10-99) */
const ONE = Array.from({length:10},(_,i)=>String(i));
const TWO = Array.from({length:90},(_,i)=>String(i+10));
const NUM_POOL = ONE.concat(TWO);

/* 檢查：一個公式內的數字 token 不可重複（token 層），且數字位元（每個字元）也不可重複（位元層）
   根據你的要求同時檢查兩者 */
function tokensUnique(nums, ops){
  const numsSet = new Set(nums);
  if (numsSet.size !== nums.length) return false;
  const opsSet = new Set(ops);
  if (opsSet.size !== ops.length) return false;
  const seen = new Set();
  for (const n of nums){
    for (const ch of n){
      if (seen.has(ch)) return false;
      seen.add(ch);
    }
  }
  return true;
}

/* permutations */
function permutations(arr){
  const res = [];
  (function perm(a,l){
    if(l===a.length){ res.push(a.slice()); return; }
    for(let i=l;i<a.length;i++){
      [a[l],a[i]]=[a[i],a[l]];
      perm(a,l+1);
      [a[l],a[i]]=[a[i],a[l]];
    }
  })(arr.slice(),0);
  return res;
}

/* ---------- 精確搜尋：優先 n=3（完全窮舉），再嘗試 n=4（有限制範圍），移除 n=5 ---------- */
const EPS = 1e-9;

// n=3 完全窮舉（包含 A），速度快、搜索空間小，優先嘗試
function findExactN3(target, luckA, luckB, luckC){
  const A = String(luckA);
  const pool = NUM_POOL.filter(x=> x !== A);
  for (let i=0;i<pool.length;i++){
    for (let j=i+1;j<pool.length;j++){
      const nums = [A, pool[i], pool[j]];
      if (!tokensUnique(nums, [luckB, luckC])) continue;
      const perms = permutations(nums);
      const opsOrders = [
        [luckB, luckC],
        [luckC, luckB]
      ];
      for (const p of perms){
        for (const ops of opsOrders){
          if (new Set(ops).size !== ops.length) continue;
          const expr = `${p[0]}${ops[0]}${p[1]}${ops[1]}${p[2]}`;
          const val = safeEval(expr);
          if (isNaN(val)) continue;
          if (Math.abs(val - target) < EPS) {
            return {
              exprJS: expr,
              exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'),
              value: val,
              error: 0,
              tokens: { numbers: p.slice(), ops: ops.slice() }
            };
          }
        }
      }
    }
  }
  return null;
}

/* n=4：受限範圍內窮舉，縮減搜索空間 */
function findExactN4(target, luckA, luckB, luckC, maxChecks = 100000){
  const smallPool = NUM_POOL.filter(s => parseInt(s) <= 30);
  const extraPool = NUM_POOL.filter(s => parseInt(s) > 30).slice(0,10);
  const pool = smallPool.concat(extraPool).filter(x => x !== String(luckA));
  const combos = [];
  function combRec(start,arr){
    if (arr.length === 3){ combos.push(arr.slice()); return; }
    for (let i=start;i<pool.length;i++){
      arr.push(pool[i]);
      combRec(i+1,arr);
      arr.pop();
      if (combos.length > 5000) return;
    }
  }
  combRec(0,[]);
  let checks = 0;
  for (const c of combos){
    const numsSet = [String(luckA)].concat(c);
    if (!tokensUnique(numsSet, ALL_OPS.slice(0,3))) continue;
    const perms = permutations(numsSet);
    for (const p of perms){
      const opsChoices = [];
      function opsRec(start,arr){
        if (arr.length === 3){
          if (arr.includes(luckB) && arr.includes(luckC) && (new Set(arr).size === arr.length)){
            opsChoices.push(arr.slice());
          }
          return;
        }
        for (let t=start;t<ALL_OPS.length;t++){
          arr.push(ALL_OPS[t]);
          opsRec(t+1,arr);
          arr.pop();
        }
        if (opsChoices.length > 50) return;
      }
      opsRec(0,[]);
      for (const opsSet of opsChoices){
        const opsPerms = permutations(opsSet);
        for (const ops of opsPerms){
          if (!tokensUnique(p, ops)) continue;
          let expr = "";
          for (let idx=0; idx<p.length; idx++){
            expr += p[idx];
            if (idx < ops.length) expr += ops[idx];
          }
          const val = safeEval(expr);
          checks++;
          if (!isNaN(val) && Math.abs(val - target) < EPS){
            return {
              exprJS: expr,
              exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'),
              value: val,
              error: 0,
              tokens: { numbers: p.slice(), ops: ops.slice() }
            };
          }
          if (checks > maxChecks) return null;
        }
      }
      if (checks > maxChecks) break;
    }
    if (checks > maxChecks) break;
  }
  return null;
}

/* findExact: 由 n=3 開始，若找不到則嘗試 n=4，移除 n=5 */
function findExactFormula(target, luckA, luckB, luckC){
  const r3 = findExactN3(target, luckA, luckB, luckC);
  if (r3) return r3;
  const r4 = findExactN4(target, luckA, luckB, luckC, 100000);
  if (r4) return r4;
  return null;
}

/* ---------- 回退：若找不到精確解，使用近似 / 局部精修（優化搜索效率） ---------- */
function refineFormula(formulaObj, target, luckA, luckB, luckC){
  let best = {
    exprJS: formulaObj.exprJS,
    exprShow: formulaObj.exprShow,
    value: formulaObj.value,
    error: Math.abs(formulaObj.value - target),
    tokens: {
      numbers: formulaObj.tokens.numbers.slice(),
      ops: formulaObj.tokens.ops.slice()
    }
  };
  const MAX_ITERS = 4; // 減少迭代次數
  const NEIGHBOR_RANGE = 10; // 縮減鄰域範圍
  for (let iter=0; iter<MAX_ITERS; iter++){
    let improved = false;
    let candidateBest = null;
    const nums = best.tokens.numbers.map(s=>String(s));
    const ops = best.tokens.ops.slice();

    for (let i=0;i<nums.length;i++){
      if (nums[i] === String(luckA)) continue;
      const cur = parseInt(nums[i]);
      const minV = Math.max(0, cur - NEIGHBOR_RANGE);
      const maxV = Math.min(99, cur + NEIGHBOR_RANGE);
      for (let v=minV; v<=maxV; v++){
        if (v === cur) continue;
        const sV = String(v);
        if (!NUM_POOL.includes(sV) || nums.includes(sV)) continue;
        const tempNums = nums.slice(); tempNums[i]=sV;
        if (!tokensUnique(tempNums, ops)) continue;
        const expr = tempNums.map((n,j)=> n + (j<ops.length?ops[j]:"")).join("");
        const val = safeEval(expr);
        if (isNaN(val)) continue;
        const err = Math.abs(val - target);
        if (err < best.error && (!candidateBest || err < candidateBest.error)){
          candidateBest = {
            exprJS: expr,
            exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'),
            value: val,
            error: err,
            tokens: { numbers: tempNums.slice(), ops: ops.slice() }
          };
        }
      }
    }

    for (let j=0;j<ops.length;j++){
      if (ops[j] === luckB || ops[j] === luckC) continue;
      for (const candidateOp of ALL_OPS){
        if (candidateOp === ops[j]) continue;
        const newOps = ops.slice(); newOps[j] = candidateOp;
        if (new Set(newOps).size !== newOps.length) continue;
        if (!newOps.includes(luckB) || !newOps.includes(luckC)) continue;
        const expr = best.tokens.numbers.map((n,k)=> n + (k<newOps.length?newOps[k]:"")).join("");
        const val = safeEval(expr);
        if (isNaN(val)) continue;
        const err = Math.abs(val - target);
        if (err < best.error && (!candidateBest || err < candidateBest.error)){
          candidateBest = { exprJS: expr, exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'), value: val, error: err, tokens: { numbers: best.tokens.numbers.slice(), ops: newOps.slice() } };
        }
      }
    }

    if (candidateBest && candidateBest.error < best.error){ best = candidateBest; improved = true; }
    if (!improved) break;
  }
  return best;
}

function findBestApproxBase(target, luckA, luckB, luckC, trials=2000){
  const seen = new Set();
  const candidates = [];
  const pool = NUM_POOL.filter(x=> x !== String(luckA));
  for (let i=0;i<trials;i++){
    const numbersCount = pick([3,4]);
    const chosen = [String(luckA)];
    const shuffledPool = shuffle(pool);
    for (const p of shuffledPool){
      if (chosen.length >= numbersCount) break;
      if (!chosen.includes(p)) chosen.push(p);
    }
    if (chosen.length < numbersCount) continue;
    const opsCount = numbersCount - 1;
    if (opsCount < 2) continue;
    const ops = [luckB, luckC];
    if (opsCount > ops.length){
      const extras = ALL_OPS.filter(o=> !ops.includes(o));
      const take = shuffle(extras).slice(0, opsCount - ops.length);
      ops.push(...take);
    }
    if (new Set(ops).size !== ops.length) continue;
    const numsShuffled = shuffle(chosen);
    const opsShuffled = shuffle(ops);
    if (!tokensUnique(numsShuffled, opsShuffled)) continue;
    const expr = numsShuffled.map((n,i)=> n + (i < opsShuffled.length ? opsShuffled[i] : "")).join("");
    if (seen.has(expr)) continue;
    seen.add(expr);
    const val = safeEval(expr);
    if (isNaN(val)) continue;
    const err = Math.abs(val - target);
    if (err <= 10) {
      const ev = { exprJS: expr, exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'), value: val, error: err, tokens: { numbers: numsShuffled.slice(), ops: opsShuffled.slice() } };
      candidates.push(ev);
    }
  }

  if (candidates.length === 0) return null;
  candidates.sort((a,b)=> a.error - b.error);
  const topK = Math.min(50, candidates.length);
  const refined = [];
  for (let i=0;i<topK;i++){
    refined.push(refineFormula(candidates[i], target, luckA, luckB, luckC));
  }
  refined.sort((a,b)=> a.error - b.error);
  return refined[0];
}

/* ---------- 從 base 產生 5 個變體（以 base 為中心變化、保證不重複 token） ---------- */
function produceFiveFromBase(baseObj, target, luckA, luckB, luckC){
  const produced = [];
  const existing = new Set();
  if (baseObj){
    produced.push(baseObj);
    existing.add(baseObj.exprJS);
  }

  const attemptsLimit = 5000;
  let attempts = 0;
  while (produced.length < 5 && attempts < attemptsLimit){
    attempts++;
    const src = produced[0] || baseObj;
    if (!src) break;

    const nums = src.tokens.numbers.slice();
    const ops = src.tokens.ops.slice();

    if (Math.random() < 0.75){
      const choices = [];
      for (let i=0;i<nums.length;i++) if (nums[i] !== String(luckA)) choices.push(i);
      if (choices.length === 0) continue;
      const idx = pick(choices);
      const cur = parseInt(nums[idx]);
      const candList = [];
      const minV = Math.max(0, cur - 10);
      const maxV = Math.min(99, cur + 10);
      for (let v=minV; v<=maxV; v++) if (v !== cur) candList.push(String(v));
      const extras = shuffle(NUM_POOL).slice(0,15);
      for (const e of extras) if (!candList.includes(e)) candList.push(e);

      let made = false;
      for (const cand of candList){
        if (nums.includes(cand)) continue;
        const tmpNums = nums.slice(); tmpNums[idx] = cand;
        if (!tokensUnique(tmpNums, ops)) continue;
        const expr = tmpNums.map((n,i)=> n + (i<ops.length?ops[i]:"")).join("");
        if (existing.has(expr)) continue;
        const val = safeEval(expr);
        if (isNaN(val)) continue;
        const candidate = refineFormula({ exprJS: expr, exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'), value: val, error: Math.abs(val-target), tokens: { numbers: tmpNums.slice(), ops: ops.slice() } }, target, luckA, luckB, luckC);
        if (existing.has(candidate.exprJS)) continue;
        if (candidate.error <= 10) {
          produced.push(candidate);
          existing.add(candidate.exprJS);
          made = true;
          break;
        }
      }
      if (!made) continue;
    } else {
      const opIdxs = [];
      for (let j=0;j<ops.length;j++) if (ops[j] !== luckB && ops[j] !== luckC) opIdxs.push(j);
      if (opIdxs.length === 0) continue;
      const j = pick(opIdxs);
      for (const candidateOp of ALL_OPS){
        if (candidateOp === ops[j]) continue;
        const newOps = ops.slice(); newOps[j] = candidateOp;
        if (new Set(newOps).size !== newOps.length) continue;
        if (!newOps.includes(luckB) || !newOps.includes(luckC)) continue;
        const expr = nums.map((n,i)=> n + (i<newOps.length?newOps[i]:"")).join("");
        if (existing.has(expr)) continue;
        const val = safeEval(expr);
        if (isNaN(val)) continue;
        const candidate = refineFormula({ exprJS: expr, exprShow: expr.replace(/\*/g,'×').replace(/\//g,'÷'), value: val, error: Math.abs(val-target), tokens: { numbers: nums.slice(), ops: newOps.slice() } }, target, luckA, luckB, luckC);
        if (existing.has(candidate.exprJS)) continue;
        if (candidate.error <= 10) {
          produced.push(candidate);
          existing.add(candidate.exprJS);
          break;
        }
      }
    }
  }

  while (produced.length < 5){
    const newBase = findBestApproxBase(target, luckA, luckB, luckC, 1000);
    if (!newBase) continue;
    if (existing.has(newBase.exprJS)) continue;
    if (newBase.error <= 10) {
      produced.push(newBase);
      existing.add(newBase.exprJS);
    }
  }
  produced.sort((a,b)=> a.error - b.error);
  return produced.slice(0,5);
}

/* ---------- UI 與主流程（保持你原本的 DOM ID 與使用者互動不變） ---------- */
const d0 = document.getElementById("d0");
const d1 = document.getElementById("d1");
const d2 = document.getElementById("d2");
const luckAEl = document.getElementById("luckA");
const luckBEl = document.getElementById("luckB");
const luckCEl = document.getElementById("luckC");
const formulaRows = document.getElementById("formulaRows");
const errorRows = document.getElementById("errorRows");
const regenBtn = document.getElementById("regenBtn");
const manualBtn = document.getElementById("manualBtn");
const modal = document.getElementById("manualModal");
const manualTarget = document.getElementById("manualTarget");
const manualA = document.getElementById("manualA");
const manualB = document.getElementById("manualB");
const manualC = document.getElementById("manualC");
const manualOk = document.getElementById("manualOk");
const manualCancel = document.getElementById("manualCancel");
const loadingOverlay = document.getElementById("loadingOverlay");

function initFiveRows(){
  formulaRows.innerHTML = "";
  errorRows.innerHTML = "";
  for (let i=0;i<5;i++){
    const row = document.createElement("div");
    row.className="row";
    row.innerHTML = `<div class="idx">${i+1}.</div><div class="expr" id="expr${i}">-</div>`;
    formulaRows.appendChild(row);
    const er = document.createElement("div"); er.className="err-row"; er.id = "err"+i; er.textContent="-";
    errorRows.appendChild(er);
  }
}
function fillRows(arr){
  for (let i=0;i<5;i++){
    const exprDiv = document.getElementById("expr"+i);
    const errDiv = document.getElementById("err"+i);
    if (!arr[i] || arr[i].exprShow === "-"){
      exprDiv.textContent = "-";
      errDiv.textContent = "-";
    } else {
      exprDiv.textContent = `${arr[i].exprShow} = ${fmtNum(arr[i].value)}`;
      errDiv.textContent = (arr[i].error === Infinity) ? "-" : fmtNum(arr[i].error);
    }
  }
}

/* 隨機產題（外部介面） */
function generateLuckAndTarget(){
  const target = randInt(100,999);
  const luckA = String(randInt(0,9));
  const luckB = pick(MUL_DIV);
  const luckC = pick(ADD_SUB);
  return { target, luckA, luckB, luckC };
}

/* 主生成流程：先找 exact（n=3->4），若找不到 exact 再用 approximate base */
function regenerate(){
  loadingOverlay.style.display = "flex";
  initFiveRows();
  const { target, luckA, luckB, luckC } = generateLuckAndTarget();
  const s = String(target).padStart(3,"0");
  d0.textContent = s[0]; d1.textContent = s[1]; d2.textContent = s[2];
  luckAEl.textContent = luckA; luckBEl.textContent = OPS_SHOW[luckB]; luckCEl.textContent = OPS_SHOW[luckC];

  let base = findExactFormula(target, luckA, luckB, luckC);
  if (base){
    const produced = produceFiveFromBase(base, target, luckA, luckB, luckC);
    fillRows(produced);
    setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
    return;
  }

  const approxBase = findBestApproxBase(target, luckA, luckB, luckC, 2000);
  if (!approxBase){
    const fallbackBase = findBestApproxBase(target, luckA, luckB, luckC, 3000);
    const produced = produceFiveFromBase(fallbackBase, target, luckA, luckB, luckC);
    fillRows(produced);
    setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
    return;
  }
  const produced = produceFiveFromBase(approxBase, target, luckA, luckB, luckC);
  fillRows(produced);
  setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
}

/* 手動自訂的流程 */
function regenerateCustom(target, luckA, luckB, luckC){
  loadingOverlay.style.display = "flex";
  initFiveRows();
  const s = String(target).padStart(3,"0");
  d0.textContent = s[0]; d1.textContent = s[1]; d2.textContent = s[2];
  luckAEl.textContent = String(luckA); luckBEl.textContent = OPS_SHOW[luckB]; luckCEl.textContent = OPS_SHOW[luckC];

  let base = findExactFormula(target, luckA, luckB, luckC);
  if (base){
    const produced = produceFiveFromBase(base, target, luckA, luckB, luckC);
    fillRows(produced);
    setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
    return;
  }
  const approxBase = findBestApproxBase(target, luckA, luckB, luckC, 2000);
  if (!approxBase){
    const fallbackBase = findBestApproxBase(target, luckA, luckB, luckC, 3000);
    const produced = produceFiveFromBase(fallbackBase, target, luckA, luckB, luckC);
    fillRows(produced);
    setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
    return;
  }
  const produced = produceFiveFromBase(approxBase, target, luckA, luckB, luckC);
  fillRows(produced);
  setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
}

/* 綁定 UI 行為（保留原本按鈕行為） */
initFiveRows();
regenerate();
regenBtn.addEventListener("click", () => {
  loadingOverlay.style.display = "flex";
  setTimeout(regenerate, 0);
});
manualBtn.addEventListener("click", ()=> { modal.style.display="flex"; });
manualCancel.addEventListener("click", ()=> { modal.style.display="none"; });
manualOk.addEventListener("click", ()=>{
  const t = parseInt(manualTarget.value);
  const a = manualA.value;
  const b = manualB.value;
  const c = manualC.value;
  if (!t || t<100 || t>999){ alert("目標數字必須 100~999"); return; }
  if (a==="" || a<0 || a>9){ alert("幸運方塊 A 必須 0~9"); return; }
  loadingOverlay.style.display = "flex";
  setTimeout(() => regenerateCustom(t,String(a),b,c), 0);
  modal.style.display="none";
});
</script>
</body>
</html>
